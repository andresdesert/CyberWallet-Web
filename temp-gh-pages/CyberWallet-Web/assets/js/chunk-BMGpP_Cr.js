import{r as e}from"./chunk-BP8el2rJ.js";import{I as n,c as t,R as s,d as a}from"./index-B7Z_1TZN.js";const r={},o=(e,n,t,s)=>{c(t)&&r[t]||(c(t)&&(r[t]=new Date),((e,n,t,s)=>{const a=[t,{code:n,...s||{}}];if(e?.services?.logger?.forward)return e.services.logger.forward(a,"warn","react-i18next::",!0);c(a[0])&&(a[0]=`react-i18next:: ${a[0]}`),e?.services?.logger?.warn?e.services.logger.warn(...a):console})(e,n,t,s))},i=(e,n)=>()=>{if(e.isInitialized)n();else{const t=()=>{setTimeout(()=>{e.off("initialized",t)},0),n()};e.on("initialized",t)}},l=(e,n,t)=>{e.loadNamespaces(n,i(e,t))},u=(e,n,t,s)=>{if(c(t)&&(t=[t]),e.options.preload&&e.options.preload.indexOf(n)>-1)return l(e,t,s);t.forEach(n=>{e.options.ns.indexOf(n)<0&&e.options.ns.push(n)}),e.loadLanguages(n,i(e,s))},c=e=>"string"==typeof e,g=(e,n,t,s)=>e.getFixedT(n,t,s),d=(r,i={})=>{const{i18n:d}=i,{i18n:f,defaultNS:p}=e.useContext(n)||{},h=d||f||t();if(h&&!h.reportNamespaces&&(h.reportNamespaces=new s),!h){o(h,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const e=(e,n)=>{return c(n)?n:"object"==typeof(t=n)&&null!==t&&c(n.defaultValue)?n.defaultValue:Array.isArray(e)?e[e.length-1]:e;var t},n=[e,{},!1];return n.t=e,n.i18n={},n.ready=!1,n}h.options.react?.wait&&o(h,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const m={...a(),...h.options.react,...i},{useSuspense:N,keyPrefix:w}=m;let y=r||p||h.options?.defaultNS;y=c(y)?[y]:y||["translation"],h.reportNamespaces.addUsedNamespaces?.(y);const x=(h.isInitialized||h.initializedStoreOnce)&&y.every(e=>((e,n,t={})=>n.languages&&n.languages.length?n.hasLoadedNamespace(e,{lng:t.lng,precheck:(n,s)=>{if(t.bindI18n?.indexOf("languageChanging")>-1&&n.services.backendConnector.backend&&n.isLanguageChangingTo&&!s(n.isLanguageChangingTo,e))return!1}}):(o(n,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:n.languages}),!0))(e,h,m)),E=((n,t,s,a)=>e.useCallback(g(n,t,s,a),[n,t,s,a]))(h,i.lng||null,"fallback"===m.nsMode?y:y[0],w),b=()=>E,I=()=>g(h,i.lng||null,"fallback"===m.nsMode?y:y[0],w),[T,v]=e.useState(b);let S=y.join();i.lng&&(S=`${i.lng}${S}`);const k=(n=>{const t=e.useRef();return e.useEffect(()=>{t.current=n},[n,void 0]),t.current})(S),C=e.useRef(!0);e.useEffect(()=>{const{bindI18n:e,bindI18nStore:n}=m;C.current=!0,x||N||(i.lng?u(h,i.lng,y,()=>{C.current&&v(I)}):l(h,y,()=>{C.current&&v(I)})),x&&k&&k!==S&&C.current&&v(I);const t=()=>{C.current&&v(I)};return e&&h?.on(e,t),n&&h?.store.on(n,t),()=>{C.current=!1,h&&e?.split(" ").forEach(e=>h.off(e,t)),n&&h&&n.split(" ").forEach(e=>h.store.off(e,t))}},[h,S]),e.useEffect(()=>{C.current&&x&&v(b)},[h,w,x]);const O=[T,h,x];if(O.t=T,O.i18n=h,O.ready=x,x)return O;if(!x&&!N)return O;throw new Promise(e=>{i.lng?u(h,i.lng,y,()=>e()):l(h,y,()=>e())})};export{d as u};

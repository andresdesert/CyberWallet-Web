import{r as e,ak as n,al as t,am as a,an as s}from"./index-CAkMPucN.js";const r={},i=(e,n,t,a)=>{c(t)&&r[t]||(c(t)&&(r[t]=new Date),((e,n,t,a)=>{const s=[t,{code:n,...a||{}}];if(e?.services?.logger?.forward)return e.services.logger.forward(s,"warn","react-i18next::",!0);c(s[0])&&(s[0]=`react-i18next:: ${s[0]}`),e?.services?.logger?.warn?e.services.logger.warn(...s):console})(e,n,t,a))},o=(e,n)=>()=>{if(e.isInitialized)n();else{const t=()=>{setTimeout(()=>{e.off("initialized",t)},0),n()};e.on("initialized",t)}},l=(e,n,t)=>{e.loadNamespaces(n,o(e,t))},u=(e,n,t,a)=>{if(c(t)&&(t=[t]),e.options.preload&&e.options.preload.indexOf(n)>-1)return l(e,t,a);t.forEach(n=>{e.options.ns.indexOf(n)<0&&e.options.ns.push(n)}),e.loadLanguages(n,o(e,a))},c=e=>"string"==typeof e,g=(e,n,t,a)=>e.getFixedT(n,t,a),d=(r,o={})=>{const{i18n:d}=o,{i18n:f,defaultNS:p}=e.useContext(n)||{},h=d||f||t();if(h&&!h.reportNamespaces&&(h.reportNamespaces=new a),!h){i(h,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const e=(e,n)=>{return c(n)?n:"object"==typeof(t=n)&&null!==t&&c(n.defaultValue)?n.defaultValue:Array.isArray(e)?e[e.length-1]:e;var t},n=[e,{},!1];return n.t=e,n.i18n={},n.ready=!1,n}h.options.react?.wait&&i(h,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const m={...s(),...h.options.react,...o},{useSuspense:N,keyPrefix:w}=m;let y=r||p||h.options?.defaultNS;y=c(y)?[y]:y||["translation"],h.reportNamespaces.addUsedNamespaces?.(y);const x=(h.isInitialized||h.initializedStoreOnce)&&y.every(e=>((e,n,t={})=>n.languages&&n.languages.length?n.hasLoadedNamespace(e,{lng:t.lng,precheck:(n,a)=>{if(t.bindI18n?.indexOf("languageChanging")>-1&&n.services.backendConnector.backend&&n.isLanguageChangingTo&&!a(n.isLanguageChangingTo,e))return!1}}):(i(n,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:n.languages}),!0))(e,h,m)),E=((n,t,a,s)=>e.useCallback(g(n,t,a,s),[n,t,a,s]))(h,o.lng||null,"fallback"===m.nsMode?y:y[0],w),b=()=>E,I=()=>g(h,o.lng||null,"fallback"===m.nsMode?y:y[0],w),[T,v]=e.useState(b);let S=y.join();o.lng&&(S=`${o.lng}${S}`);const k=(n=>{const t=e.useRef();return e.useEffect(()=>{t.current=n},[n,void 0]),t.current})(S),C=e.useRef(!0);e.useEffect(()=>{const{bindI18n:e,bindI18nStore:n}=m;C.current=!0,x||N||(o.lng?u(h,o.lng,y,()=>{C.current&&v(I)}):l(h,y,()=>{C.current&&v(I)})),x&&k&&k!==S&&C.current&&v(I);const t=()=>{C.current&&v(I)};return e&&h?.on(e,t),n&&h?.store.on(n,t),()=>{C.current=!1,h&&e?.split(" ").forEach(e=>h.off(e,t)),n&&h&&n.split(" ").forEach(e=>h.store.off(e,t))}},[h,S]),e.useEffect(()=>{C.current&&x&&v(b)},[h,w,x]);const O=[T,h,x];if(O.t=T,O.i18n=h,O.ready=x,x)return O;if(!x&&!N)return O;throw new Promise(e=>{o.lng?u(h,o.lng,y,()=>e()):l(h,y,()=>e())})};export{d as u};
